package edu.utsa.mobbed;

import java.sql.*;
import java.util.UUID;

/**
 * Handler class for EVENTS table. An Event is a recorded activity generated by
 * system or from the subject of the experiment. Class contains functions to
 * store, retrieve, delete or making any other queries on the table. A record in
 * the table is uniquely identified by EVENT_UUID.
 * 
 * @author Arif Hossain, Kay Robbins
 * 
 */

public class Events {

	private Attributes atb;
	private double[] certainties;
	private UUID datasetUuid;
	private Structures dataStruct;
	private Connection dbCon;
	private String eventField;
	private Structures eventStruct;
	private UUID[] eventUuids;
	private EventTypes evType;
	private EventTypeMaps evTypeMap;
	private String[] existingUuids;
	private PreparedStatement insertStmt;
	private String modalityName;
	private long[] positions;
	private double[] startTimes;
	private double[] endTimes;
	private String[] types;
	private String[] uniqueTypes;
	private static final String insertQry = "INSERT INTO EVENTS (EVENT_UUID, EVENT_ENTITY_UUID, "
			+ "EVENT_TYPE_UUID, EVENT_POSITION, EVENT_START_TIME,"
			+ " EVENT_END_TIME, EVENT_CERTAINTY) VALUES (?, ?, ?, ?, ?, ?, ?)";

	/**
	 * create an Events object
	 * 
	 * @param dbCon
	 *            connection to the database
	 * @param datasetUuid
	 *            UUID of the entity
	 */
	public Events(Connection dbCon) throws Exception {
		this.dbCon = dbCon;
		this.datasetUuid = null;
		this.modalityName = null;
		this.types = null;
		this.positions = null;
		this.startTimes = null;
		this.endTimes = null;
		this.certainties = null;
		this.uniqueTypes = null;
		this.dataStruct = null;
	}

	public void addAttribute(String fieldName, Double[] numericFieldValues,
			String[] fieldValues) throws Exception {
		addNewStructure(fieldName, MobbedConstants.HANDLER_REQUIRED);
		UUID structureUUID = eventStruct.getChildrenByName(fieldName);
		for (int i = 0; i < types.length; i++) {
			atb.reset(UUID.randomUUID(), eventUuids[i], datasetUuid,
					structureUUID, numericFieldValues[i], fieldValues[i]);
			atb.addToBatch();
		}
	}

	/**
	 * add Events to the database
	 * 
	 * @throws Exception
	 */
	public String[] addEvents() throws Exception {

		insertStmt = dbCon.prepareStatement(insertQry);
		addNewTypes();
		addTypeMaps();
		eventUuids = new UUID[types.length];
		for (int i = 0; i < types.length; i++) {
			// event uuid that attributes use
			eventUuids[i] = UUID.randomUUID();
			// set query parameters for event
			insertStmt.setObject(1, eventUuids[i], Types.OTHER);
			insertStmt.setObject(2, datasetUuid, Types.OTHER);
			insertStmt.setObject(3, evType.getTypeUuid(types[i].toUpperCase()),
					Types.OTHER);
			insertStmt.setLong(4, positions[i]);
			insertStmt.setDouble(5, startTimes[i]);
			insertStmt.setDouble(6, endTimes[i]);
			insertStmt.setDouble(7, certainties[i]);
			insertStmt.addBatch();
		}
		return evType.getStringValues();
	}

	/**
	 * Add a new structure to the elementStruct
	 * 
	 * @param fieldName
	 *            name of the structure element to be added
	 * @param handler
	 *            - code for the integer
	 * @throws Exception
	 */
	private void addNewStructure(String fieldName, int handler)
			throws Exception {
		eventStruct = Structures.retrieve(dbCon, eventField,
				dataStruct.getStructureUuid(), true);
		if (!eventStruct.containsChild(fieldName)) {
			Structures newStructure = new Structures(dbCon);
			newStructure.reset(UUID.randomUUID(), fieldName, handler,
					eventStruct.getStructureUuid());
			newStructure.save();
			eventStruct = Structures.retrieve(dbCon, "event",
					dataStruct.getStructureUuid(), true);
		}
	}

	private void addNewTypes() throws Exception {
		if (existingUuids != null)
			evType.retrieveName2UuidMap(existingUuids);
		for (int i = 0; i < uniqueTypes.length; i++) {
			if (!evType.typeExists(uniqueTypes[i].toUpperCase())) {
				evType.reset(uniqueTypes[i], null);
				evType.save();
				evType.addToHashMap();
			}
		}
	}

	private void addTypeMaps() throws Exception {
		UUID[] eventTypeUuids = evType.getUUIDValues();
		int eventUuidsSize = eventTypeUuids.length;
		for (int i = 0; i < eventUuidsSize; i++) {
			evTypeMap.reset(eventTypeUuids[i], datasetUuid, "dataset");
			evTypeMap.save();
		}
	}

	/**
	 * Create a new set of events to be added to the database
	 * 
	 * @param eventField
	 * @param uniqueTypes
	 * @param types
	 * @param positions
	 * @param startTimes
	 * @param endTimes
	 * @param otherFields
	 * @throws Exception
	 */
	public void reset(String datasetUuid, String eventField,
			String[] defaultFields, String uniqueTypes[], String[] types,
			long[] positions, double[] startTimes, double[] endTimes,
			double[] certainties, String[] existingUuids) throws Exception {
		this.datasetUuid = UUID.fromString(datasetUuid);
		this.eventField = eventField;
		this.types = types;
		this.positions = positions;
		this.startTimes = startTimes;
		this.endTimes = endTimes;
		this.certainties = certainties;
		this.uniqueTypes = uniqueTypes;
		this.existingUuids = existingUuids;
		atb = new Attributes(dbCon);
		evType = new EventTypes(dbCon);
		evTypeMap = new EventTypeMaps(dbCon);
		modalityName = Structures.retrieveModalityName(dbCon,
				UUID.fromString(datasetUuid));
		dataStruct = Structures.retrieve(dbCon, modalityName, null, false);
	}

	/**
	 * save all the elements as a batch operation
	 * 
	 * @return boolean - true if successfully stored, false otherwise
	 */
	public void save() throws Exception {
		try {
			insertStmt.executeBatch();
			if (atb.getBatchCount() > 0)
				atb.save();
		} catch (Exception ex) {
			throw new MobbedException("Could not save events");
		}
	}

}
